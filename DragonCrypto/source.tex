\documentclass[a4paper,12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[top=0.5in,left=0.5in,right=0.5in,bottom=0.5in]{geometry}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage{caption}
\usepackage{graphicx}
\graphicspath{{}}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

%\theoremstyle{plain}
\newtheorem*{theorem}{Theorem}
\hbadness = 10001

\begin{document}
\title{Dragon Crypto - An innovative cryptosystem} % title

\author{ 
   \large Awnon Bhowmik \\[-3pt]
   \normalsize Department of Mathematics and Computer Science, CUNY York College  \\[-3pt]
    \normalsize 90-24 Guy R. Brewer Blvd \\[-3pt]
    \normalsize Jamaica, NY 11451 \\[-3pt]
    \normalsize	awnon.bhowmik@yorkmail.cuny.edu \\[-3pt]
  \and
   \large Unnikrishnan Menon \\[-3pt]
   \normalsize Department of Electrical and Electronics Engineering, Vellore Institute of Technology  \\[-3pt]
    \normalsize Vellore Campus, Tiruvalam Rd \\[-3pt]
    \normalsize Katpadi, Vellore,
Tamil Nadu 632014 \\[-3pt]
    \normalsize	unnikrishnanr.menon2017@vitstudent.ac.in \\[-3pt]
% \and
%   \large 3rd Author \\[-3pt]
%   \normalsize 3rd author's affiliation  \\[-3pt]
%     \normalsize 1st line of address \\[-3pt]
%     \normalsize 2nd line of address \\[-3pt]
%     \normalsize	3rd author's email address \\[-3pt]
}

%\terms{Algorithm}

\maketitle



\begin{abstract} 
  In recent years cyber-attacks are continuously developing, therefore security specialists must stay busy in the lab inventing new schemes to keep attackers at bay. In this paper we outline the details of a new crypto system based on the dragon curve fractal. The security level of this scheme is based on multiple private keys, that are crucial for effective encryption and decryption of data. This paper covers how core concepts emerging from fractal geometry can be used as a trapdoor function for a new cryptosystem.
  
  \begin{flushleft}
  keywords: dragon curve, dragon fractal, dragon curve fractal, heighway dragon curve, heighway dragon fractal, cryptography, cryptosystem, crypto system, secure encryption, Iterative Function System, IFS, iteration, precision, trapdoor function
  \end{flushleft}
\end{abstract}

\section{Introduction}
\begin{flushleft}
    Fractals are just a self replication of a particular pattern. There are many fractals that are found in nature. One such fractal curve is known as \textit{Heighway Dragon}, or simply the \textit{Dragon Curve}. Because this is a fractal, hence it requires an IFS (Iterated Function System). In simple words, we make a simple pattern, put it into a recursive function, before running a loop and calling the function over and over again until our objective is accomplished.
\end{flushleft}

\section{The Dragon Fractal}
\begin{flushleft}
        A fractal is a repetition of an initial geometric shape. This is generated by something known as the Iterative Function System (IFS). The dragon curve is one such fractal. There are multiple ways to generate this fractal. 
\end{flushleft}

\subsection{Generating the Dragon Fractal}
\begin{flushleft}
    This dragon curve fractal, or its generation algorithm forms the basis of this cryptosystem, and hence the proposed name \textit{dragon crypto}. Here, we take an arbitrary string of characters, pass each character through the \textit{Koblitz encoder} to obtain the starting point for the IFS.
\end{flushleft}

\begin{flushleft}
	The iterations of the Dragon curve can easily be generated by folding a strip of paper $n$ number of times. We take a strip of paper and fold it in half to the right.$^{\cite{taming_the_dragon}}$ We fold it in half again, to the right. We continue this process as many times as we want (of course it will be hard to fold after a certain point). Let’s say we do it 2 times.
\end{flushleft}

\begin{flushleft}
    Now we unfold the strip and relax it, and we’ll notice that every bend/corner of the strip has become a $90^{\circ}$ turn. What we have now is the second iteration of the Dragon Curve. If we fold the strip of paper in half for a third time and then open it up, we would get the third iteration and so on…
\end{flushleft}

\begin{center}
    \begin{center}
        \includegraphics[scale=0.7]{images/paper folding.png}\captionof*{"Paper folding method".png}{Fig 1. \textbf{Paper folding method}}
    \end{center}
\end{center}

\begin{flushleft}
    Now all we have to do is visualize a turtle walking along these lines and it should be able to predict how to move. Let F = forward, L = left, R = right. The following sequences are associated with the respective iterations...
    
    \begin{itemize}
        \item 1st iteration- F L F L
        \item 2nd iteration- F L F L F R F L
        \item 3rd iteration- F L F L F R F L F L F R F R F L
        \vdots
    \end{itemize}

If we know the $n^{\text{th}}$ iteration, we can predict the $(n+1)^{\text{th}}$ iteration in the following way. Let’s say we are trying to derive the third iteration from the second iteration.

    \begin{itemize}
        \item We ignore the last element for now (F L F L F R F). In the remaining elements, if there’s a R, it is replaced by L. And if there is a L, it is replace by a R. The sequence now becomes (F R F R F L F R).
        \item Now, we flip these elements about the mid point. The sequence turns into (R F L F R F R F).
        \item Add the last element which we had ignored in the first step. The sequence becomes (R F L F R F R F L).
        \item Appending the result of step 4 to the 1st iteration and we will have our third iteration ready.
    \end{itemize}

Using this same logic, we can predict the next iterations. A fractal curve generated with $15$ iterations is as follows...

\begin{center}
    \includegraphics[scale=0.35]{images/dragoncurve.png}\captionof*{"dragoncurve".png}{Fig 2. \textbf{Dragon Curve Fractal}}
\end{center}
\end{flushleft}

\section{Koblitz Encoding \& Decoding Algorithm}
\begin{flushleft}
	The encoding algorithm$^{\cite{koblitz}}$ is as follows...\\
	\begin{itemize}
		\item Given a message $M$, convert each character $m_k$ into a number $a_k$ using Unicode, where $b=2^{16}$ and $0<a_k<2^{16}$
		\item Convert the message $M$ into an integer using $$m=\sum_{k=1}^n a_kb^{k-1}$$. In practice we choose an $n$ to be less than or equal to $160$ such that $m$ satisfies $m\le 2^{16\cdot 160}<p$.
		\item Fix a number $d$ such that $d\le \dfrac{p}{m}$. In practice we choose the prime $p$ large enough so that we can allow $d=100$.
		\item For integers $j=0,1,2,\cdots d-1$  we do the following loop
		\begin{itemize}
			\item Compute the $x$ coordinate of a point on the elliptic curve as $x_j=(dm+j)\mod p$ where $m=\bigg\lfloor{\dfrac{x_j}{d}}\bigg\rfloor$
			\item Compute $s_j=(x_j^3+Ax+B)\mod p$
			\item If $\left(s_j\right)^{\frac{p+1}{2}}\equiv s_j\mod p$, then define $y$ coordinate of a point on the elliptic curve as $y_j=\left(s_j\right)^{\frac{p+1}{4}}\mod p$. Return the point $(x_j,y_j)$.
		\end{itemize}
	\end{itemize}
	
	Thus we are able to encode our message $M$, as an element of the Abelian group $G=E\left(\mathbb{F}_p\right)$.
	
	The decoding algorithm is as follows...\\
	\begin{itemize}
	    \item Consider each point $(x,y)$ and set $m$ to be the greatest integer less than $\dfrac{x-1}k$. Then the point $(x,y)$ decodes as the symbol $m$. 
	\end{itemize}
\end{flushleft}

\section{Trapdoor Function}
\begin{flushleft}
A trapdoor function is a function that is easy to compute in one direction, yet difficult to compute in the opposite direction without special information, called the \textit{trapdoor}. Trapdoor functions came to prominence in cryptography in the mid-1970s with the publication of asymmetric (or public-key) encryption techniques. Several function classes have been proposed, and it soon became obvious that trapdoor functions are harder to find than was initially thought.
\end{flushleft}

\begin{flushleft}
The main novelty of our cryptosystem is the use of \textbf{The Heighway Dragon Fractal} as a trapdoor function. The algorithm starts off with a secret message that needs to be encrypted (called the plainText).
\end{flushleft}

\begin{flushleft}
The Koblitz encoder accepts the plainText along with the curve parameters (obtained from the private key). The koblitz encoder spits out an encoded point in 2D Cartesian space for each character present in the plainText with the help of curve parameters.These points are now the starting point of the dragon curve fractals. For each character, a corresponding starting point and a dragon fractal are generated.
\end{flushleft}

\begin{flushleft}
Now the components of the private key (including size,iterations,angle) are used to generate the the fractal for each character from their corresponding starting points.
\end{flushleft}

\begin{flushleft}
\textbf{Private key parameters}
\begin{itemize}
	\item The size defines the length of each forward step.
	\item The Iterations defines the number of iterations for generating the fractal.
	\item The Angle defines the starting angle for the fractal.
	\item Elliptic curve parameters $a$ and $b$ for the function $y^2=x^3+ax+b$
\end{itemize}
\end{flushleft}

\begin{flushleft}
Once the fractals are generated for each encoded starting points, the corresponding ending points are noted and stored.

\begin{align*}
	p_{\text{start}}&=\left\{(x_i,y_i)\right\}\qquad i=1,2,\cdots n\\
	p_{\text{end}}&=\left\{(x_j,y_j)\right\}\qquad j=1,2,\cdots n
\end{align*}
\end{flushleft}

\section{Proposed Algorithm}
    \begin{enumerate}
        \item Input an arbitrary string, and split into list of characters, spaces and special characters
        \item Encryption
        \begin{enumerate}
            \item Pass each character's ASCII representation through the Koblitz encoder (using Koblitz Algorithm in section 3). Every character is then represented by a point $(x_i,y_i)$ on the Cartesian coordinate. Let's call these set of points as initial starting points.
            \item For a fixed length $l$, an angle $\theta$ and a fixed number of iterations $n$ for all characters (or points) in the set, we generate a dragon fractal curve. The end point $(x_j,y_j)$ for each starting point $(x_i,y_i)$ is stored into another list.
            \item A special padding is applied on the list of end points as follows $$"Xx_1Xx_2\cdots Xx_nXYy_1Yy_2\cdots y_nY"$$. This turns it into a string. This string is the encrypted cipher text.
        \end{enumerate}
        
        \item Decryption
        \begin{enumerate}
            \item Remove padding and regenerate points. Parse through each element of the cipher text string and split it at "XY" into $2$ sequences. So now we have $2$ strings:
                \begin{align*}
                    "Xx_1Xx_2\cdots Xx_nX"&\qquad\text{and}\qquad"Yy_1Yy_2\cdots y_nY"
                \end{align*}
            Next, we parse through the $2$ lists and recover the ordered set of end point coordinates $(x_j,y_j)$
            \item The list of end point coordinates are taken and based on the (size, iterations, angle) parameters present in the private key, a dragon curve fractal is generated in reverse by initializing the turtle at an endpoint facing the correct direction based on the angle. If the private key parameters are correct, the reversed dragon fractal will end at the initial starting point. This process is repeated for all characters. The points obtained are stored in a list.
            \item The list of points obtained from the previous step is passed through the \textbf{Koblitz Decoder}. This returns the ASCII values of each character in original string. This is finally converted to string to retrieve original message.
        \end{enumerate}
    \end{enumerate}


\section{Example demonstrating the algorithm}
\begin{center}
    \includegraphics[scale=0.77]{images/output.png}\captionof*{"output".png}{Fig 3. \textbf{Sample Test}}
\end{center}

\section{Conclusions}
\begin{flushleft}
    Cryptography is a 40 year old topic where a lot has been discovered but a lot more yet remains unknown. The essence of any traditional cryptosystem relies on three hard mathematical problems: the integer factorization problem, the discrete logarithm problem or the elliptic curve discrete logarithm problem. Shor's algorithm can be used to easily compromise the security of these conventional cryptosystems. So for a secure future, it is critical to come up with innovative trapdoor functions that can be incorporated in the heart of the encryption scheme.
\end{flushleft}

\begin{flushleft}
   In this paper, we proposed a new encryption algorithm based on the well known dragon curve fractal, due to the fact that not many people have worked on an approach that is closely related to the work discussed here. Whether on not this system is truly usable at the industry level is out of scope of this paper for the moment, but hopefully we will be able to build up on our present research work in the near future. 
\end{flushleft}

\begin{flushleft}
    We have shown that our proposed algorithm is working based on the appropriate parameters. It has been noticed that the run time complexity can be drastically reduced by using smaller number of iterations while increasing the length to compensate for the precision of the endpoint as well as the Euclidean distance from the start point. So far no edge cases have been found, but we suspect the presence of one or more. This is dependent on the calculation precision of the machine. Our work so far is available here.$^{\cite{dragon_crypto}}$
\end{flushleft}

\bibliographystyle{ieeetran}
\bibliography{References}

\end{document}